## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      è®¡ç®—æœºä¸äººå·¥æ™ºèƒ½å­¦é™¢ã€Šäººå·¥æ™ºèƒ½ç¨‹åºè®¾è®¡ã€‹å®éªŒæŠ¥å‘ŠğŸ“

| ä¸“ä¸š                 | å­¦å·         | å§“å         |
| :------------------- | ------------ | ------------ |
| æ•°æ®ç§‘å­¦ä¸å¤§æ•°æ®æŠ€æœ¯ | 2025020213   | å¼ å¯Œæ”¿       |
| **è¯¾ç¨‹åç§°**         | **å®éªŒåç§°** | **å®Œæˆæ—¥æœŸ** |
| ä¸“ä¸šç»¼åˆè®­ç»ƒI        | å®è®­ä¸€       | 2022.03.19   |



[TOC]

## ä¸€ å®éªŒç›®æ ‡

> æè¿°æœ¬æ¬¡å®éªŒæ‰€éœ€å®ç°çš„ç›®æ ‡ï¼Œè¯·æ ¹æ®å®éªŒè¯´æ˜æ–‡æ¡£å¡«å†™ã€‚

ä¾‹å¦‚ï¼š

- æŒæ¡Vs Codeã€githubçš„ä½¿ç”¨ï¼›
- æŒæ¡ä½¿ç”¨Makefileè¿›è¡Œå·¥ç¨‹ç¼–è¯‘çš„æ–¹æ³•ï¼›
- æŒæ¡ç¼–ç¨‹æ–‡æ¡£çš„æ’°å†™æ–¹æ³•ï¼›
- å¤ä¹ æ–‡ä»¶ã€å•é“¾è¡¨çš„ç¼–ç¨‹ï¼›
- å·©å›ºæ’åºç®—æ³•ã€‚	

## äºŒ å®éªŒè¦æ±‚

> å®éªŒå®Œæˆçš„å…·ä½“è¦æ±‚è¯´æ˜ã€‚

- ä¸ªäººç‹¬ç«‹å®Œæˆï¼Œç§¯æåŠ¨æ‰‹ç¼–ç¨‹ï¼›
- é¼“åŠ±ä¸åŒå­¦äº¤æµï¼Œä½†ä¸èƒ½æŠ„è¢­æºç ï¼›
- èƒ½å®Œæˆå®éªŒè¯´æ˜æ–‡æ¡£çš„å„ä¸ªæ­¥éª¤å¹¶æ’°å†™æ­¤å®éªŒæŠ¥å‘Šï¼›
- èƒ½æ¼”ç¤ºå®éªŒè¿‡ç¨‹å¹¶é˜è¿°åŠŸèƒ½çš„ä¸»è¦ä»£ç æ¨¡å—ã€‚
- å®éªŒæŠ¥å‘Šè¯·çªå‡ºè‡ªå·±çš„**æƒ³æ³•**ã€**åšæ³•**ã€**å¿ƒå¾—ä½“ä¼š**ï¼›

## ä¸‰ å®éªŒç¯å¢ƒ

> åˆ—ä¸¾å®éªŒå®Œæˆè¿‡ç¨‹ä¸­ä½¿ç”¨åˆ°çš„ä¸»è¦å·¥å…·ä»¥åŠä¸»è¦çš„**å‚è€ƒèµ„æ–™**ã€‚

ä¾‹å¦‚ï¼š

- Vs Codeã€Githubã€Typoraï¼›
- ä¹¦ï¼š
- ç½‘ç«™ï¼š



## å›› å®éªŒå†…å®¹

> æŠ¥å‘Šçš„**ä¸»ä½“éƒ¨åˆ†**ã€‚è¯¦ç»†è¯´æ˜æ¯éƒ¨åˆ†ä»»åŠ¡çš„ä»»åŠ¡æè¿°ã€å®ç°æ­¥éª¤ã€å®ç°æ–¹æ³•ã€æµ‹è¯•è¯´æ˜ã€å®ç°ç—•è¿¹ï¼Œå®ç°æ–¹æ³•è¯·==çªå‡ºé‡ç‚¹==ï¼Œä¸å¿…æ³›æ³›è€Œè°ˆã€‚
>
> ä»»åŠ¡æè¿°ï¼šç®€è¦è¯´æ˜æ­¤ä»»åŠ¡éœ€è¦è¾¾åˆ°çš„ç›®çš„ï¼›
>
> å®ç°æ­¥éª¤ï¼šå®ç°æ­¤ä»»åŠ¡å¤§è‡´åˆ†ä¸ºå“ªå‡ ä¸ªé˜¶æ®µæ­¥éª¤ï¼›
>
> å®ç°æ–¹æ³•ï¼šå®ç°è¿™äº›æ­¥éª¤æ—¶ç”¨åˆ°äº†å“ªäº›ä¸»è¦çš„æ–¹æ³•ï¼ˆæ•°æ®ç»“æ„ã€ç®—æ³•ã€ç¼–ç¨‹æŠ€å·§ç­‰ï¼‰ï¼›
>
> æµ‹è¯•è¯´æ˜ï¼šè®¾è®¡æµ‹è¯•æ ·ä¾‹è¯´æ˜ä»»åŠ¡å®Œæˆæƒ…å†µï¼›
>
> å®ç°è¿‡ç¨‹ï¼šgit æ—¶é—´çº¿å±•ç¤ºå’Œè¯´æ˜ã€‚

###  Personé—®é¢˜

#### é—®é¢˜1ï¼šCount Until Larger

- ä»»åŠ¡æè¿°

  å®ç°å‡½æ•° `count_until_larger` , è¯¥å‡½æ•°æ¥å—ä¸€ä¸ªæ­£æ•´æ•° `num` ï¼Œç»Ÿè®¡æœ€å³è¾¹æ•°ä½ï¼ˆdigitï¼‰å’Œç¦»å®ƒæœ€è¿‘å¹¶æ¯”å®ƒå¤§çš„æ•°ä½çš„è·ç¦»ã€‚æ˜¯è¿™æ ·åšçš„ï¼Œå‡½æ•°ä»å³å¾€å·¦è®¡æ•°ï¼Œä¸€æ—¦é‡åˆ°æ¯”æœ€å³è¾¹æ•°ä½å¤§çš„æ•°ä½ï¼Œå°±è¿”å›è¿™ä¸ªè®¡æ•°ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ•°ä½ï¼Œå°±è¿”å› -1

  ä¾‹å¦‚ï¼Œ 8117 çš„æœ€å³è¾¹æ•°ä½æ˜¯ `7` å¹¶è¿”å›è®¡æ•° `3` ã€‚9118117 ä¹Ÿè¿”å›è®¡æ•° `3`ï¼Œä¸¤ä¸ªéƒ½æ˜¯åœ¨ `8` åœæ­¢è®¡æ•°ã€‚

  æ•°å­— `0` åº”è¯¥æŒ‰æ— æ•°ä½å¯¹å¾…å¹¶è¿”å› `-1` ã€‚

  å‚é˜…ä¸‹é¢çš„ doctestï¼Œäº†è§£ `count_until_larger` çš„å…·ä½“è¡Œä¸ºã€‚

  > count_until_larger.pyæºä»£ç æ–‡ä»¶åœ¨ parsons_probs æ–‡ä»¶å¤¹ä¸­ï¼Œåœ¨ç»ˆç«¯é€šè¿‡ `cd` å‘½ä»¤è¿›å…¥è¯¥æ–‡ä»¶å¤¹ï¼Œå¹¶è¾“å…¥å‘½ä»¤è¿›è¡ŒéªŒè¯ï¼š
  >
  > ```
  > python3 -m doctest count_until_larger.py
  > ```

  ```python
  def count_until_larger(num):
      """
      Complete the function count_until_larger that takes in a positive integer num.
      count_until_larger examines the rightmost digit and counts digits from right to
      left until it encounters a digit larger than the rightmost digit, then returns that count.
  
      >>> count_until_larger(117) # .Case 1
      -1
      >>> count_until_larger(8117) # .Case 2
      3
      >>> count_until_larger(9118117) # .Case 3
      3
      >>> count_until_larger(8777)  # .Case 4
      3
      >>> count_until_larger(22) # .Case 5
      -1
      >>> count_until_larger(0) # .Case 6
      -1
      """
      "*** YOUR CODE HERE ***"
  ```

- å®ç°æ­¥éª¤

  1. ä»¥numæœ€åä¸€ä½ä¸ºåŸºå‡†ï¼Œç”¨numå¯¹10å–æ¨¡ç»“æœä¸æœ€åä¸€ä½æ¯”è¾ƒï¼Œåªè¦æœ‰è¾ƒå¤§æ•°å°±ç«‹å³è¿”å›ï¼›
  2. ç›´åˆ°numä¸º0éƒ½æ— è¿”å›å€¼ï¼Œåˆ™è¿”å›-1ï¼›

- å®ç°æ–¹æ³•

  ```python
  def count_until_larger(num):
      """
      Complete the function count_until_larger that takes in a positive integer num.
      count_until_larger examines the rightmost digit and counts digits from right to
      left until it encounters a digit larger than the rightmost digit, then returns that count.
  
      >>> count_until_larger(117) # .Case 1
      -1
      >>> count_until_larger(8117) # .Case 2
      3
      >>> count_until_larger(9118117) # .Case 3
      3
      >>> count_until_larger(8777)  # .Case 4
      3
      >>> count_until_larger(22) # .Case 5
      -1
      >>> count_until_larger(0) # .Case 6
      -1
      """
      "*** YOUR CODE HERE ***"
      k = num % 10
      num //= 10
      count = 0
      while num:
          count += 1
          if num % 10 > k:
              return count
          num //= 10
      return -1
  ```

- æµ‹è¯•è¯´æ˜

  æµ‹è¯•ç»“æœï¼š

  ![DY_HZ3044IELQ5@VX__MH2E.png](https://s2.loli.net/2022/03/19/TKQMFH8IORPYpfe.png)

- å®ç°è¿‡ç¨‹

  ä»¥ä¸‹ä¸ºè¯¥ç¨‹åºçš„æ—¶é—´çº¿ï¼š

  ![XR_T_ENRFI_`GZ_EW7_B_SU.png](https://s2.loli.net/2022/03/19/Ql3uz7b9BUOqMjn.png)

#### é—®é¢˜2ï¼šFilter Sequence

- ä»»åŠ¡æè¿°

  ç¼–å†™å‡½æ•° `filter_sequence` ï¼Œæ¥å—ä¸¤ä¸ªæ•´æ•° `start` å’Œ `stop` ï¼Œå’Œä¸€ä¸ªå‡½æ•° `cond`ï¼Œ`cond` æ¥å—ä¸€ä¸ªå‚æ•°å¹¶è¾“å‡ºä¸€ä¸ªå¸ƒå°”å€¼ã€‚

   å½“ `cond` è¿”å› `True` æ—¶ï¼Œ`filter_sequence` è¿”å›ä» `start` åˆ° `stop` ï¼ˆåŒ…æ‹¬ï¼‰çš„æ‰€æœ‰æ•°ä½ï¼ˆdigitï¼‰ä¹‹å’Œã€‚

  > filter_sequence.pyæºä»£ç æ–‡ä»¶åœ¨ parsons_probs æ–‡ä»¶å¤¹ä¸­ï¼Œåœ¨ç»ˆç«¯é€šè¿‡ `cd` å‘½ä»¤è¿›å…¥è¯¥æ–‡ä»¶å¤¹ï¼Œå¹¶è¾“å…¥å‘½ä»¤è¿›è¡ŒéªŒè¯ï¼š
  >
  > ```
  > python3 -m doctest filter_sequence.py
  > ```

  ```python
  def filter_sequence(cond, start, stop):
      """
      Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy
      the one-argument function cond.
  
      >>> filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1
      30
      >>> filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2
      25
      """
      "*** YOUR CODE HERE ***"
  ```

- å®ç°æ­¥éª¤

  1. ç”¨forå¾ªç¯rangeè¿”å›çš„æ•°åˆ—ï¼›
  2. å¯¹æ•°åˆ—ä¸­çš„æ•°ç”¨condå‡½æ•°åˆ¤æ–­ True or Falseï¼ŒTrueï¼šsum+ï¼ŒFalseï¼šä¸åšå¤„ç†ï¼›
  3. è¿”å›ç»“æœï¼›

- å®ç°æ–¹æ³•

  ```python
  def filter_sequence(cond, start, stop):
      """
      Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy
      the one-argument function cond.
  
      >>> filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1
      30
      >>> filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2
      25
      """
      "*** YOUR CODE HERE ***"
      sum = 0
      for i in range(start, stop + 1):
          if cond(i):
              sum += i
      return sum
  ```

- æµ‹è¯•è¯´æ˜

  æµ‹è¯•ç»“æœï¼š

  ![YBUEK_6E_~GUH73_8SJF`_Y.png](https://s2.loli.net/2022/03/19/xekntCUV3GhTlDu.png)

- å®ç°è¿‡ç¨‹

  ä»¥ä¸‹ä¸ºè¯¥ç¨‹åºçš„æ—¶é—´çº¿ï¼š

  ![LU_`NK`XGN_`JXZR2_0_MDR.png](https://s2.loli.net/2022/03/19/9hAk8wDHlYUdoZn.png)

  

### ç¼–ç¨‹é—®é¢˜

#### é—®é¢˜3ï¼šHailstone

- ä»»åŠ¡æè¿°

  Douglas Hofstadter çš„æ™®åˆ©ç­–å¥–è·å¥–è‘—ä½œã€Š*GÃ¶delï¼Œ Escherï¼Œ Bach*ã€‹æå‡ºäº†ä»¥ä¸‹æ•°å­¦éš¾é¢˜ã€‚

  1. é€‰æ‹©ä¸€ä¸ªæ­£æ•´æ•° `n` ä½œä¸ºå¼€å§‹ã€‚
  2. å¦‚æœ `n` ä¸ºå¶æ•°ï¼Œåˆ™å°†å…¶é™¤ä»¥ 2ã€‚
  3. å¦‚æœ `n` ä¸ºå¥‡æ•°ï¼Œåˆ™å°†å…¶ä¹˜ä»¥ 3 å¹¶åŠ  1ã€‚
  4. ç»§ç»­æ­¤è¿‡ç¨‹ï¼Œç›´åˆ° `n` ä¸º 1ã€‚

  è¿™ä¸ªæ•°å­— `n` ä¼šä¸Šä¸‹ç§»åŠ¨ï¼Œä½†æœ€ç»ˆä»¥1ç»“æŸï¼ˆè‡³å°‘å¯¹äºæ‰€æœ‰å°è¯•è¿‡çš„æ•°å­—æˆç«‹ - æ²¡æœ‰äººè¯æ˜åºåˆ—ä¼šç»ˆæ­¢ï¼‰ã€‚ç±»æ¯”äºå†°é›¹ï¼ˆhailstoneï¼‰åœ¨å¤§æ°”å±‚ä¸­ä¸Šä¸‹ç§»åŠ¨ï¼Œæœ€ç»ˆé™è½åœ¨åœ°çƒä¸Šã€‚

   `n` çš„å€¼åºåˆ—é€šå¸¸è¢«ç§°ä¸ºå†°é›¹åºåˆ—ã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªæ­£å¼çš„å‚æ•°å `n`ï¼Œæ‰“å°å‡ºä» `n` å¼€å§‹çš„å†°é›¹åºåˆ—ï¼Œå¹¶è¿”å›åºåˆ—ä¸­çš„æ­¥æ•°ï¼š

  

  ç¼–å†™å‡½æ•° `falling`ï¼Œæ¥å—ä¸¤ä¸ªå‚æ•° `n` å’Œ `k` ï¼Œ è¿”å› ä» `n` å¼€å§‹çš„å€’æ•° `k` ä¸ªè¿ç»­æ•°å­—ä¹‹ç§¯ã€‚å½“ `k` ä¸º `0` æ—¶ï¼Œå‡½æ•°è¿”å›`1`

  ```python
  def hailstone(n):
      """Print the hailstone sequence starting at n and return its
      length.
  
      >>> a = hailstone(10)
      10
      5
      16
      8
      4
      2
      1
      >>> a
      7
      >>> b = hailstone(1)
      1
      >>> b
      1
      """
      "*** YOUR CODE HERE ***"
  ```

  å†°é›¹åºåˆ—å¯ä»¥éå¸¸é•¿ï¼è¯•è¯• 27ã€‚ä½ èƒ½æ‰¾åˆ°çš„æœ€é•¿åºåˆ—æ˜¯ï¼Ÿ

  ä½¿ç”¨ Ok æµ‹è¯•ä½ çš„ä»£ç ï¼š

  ```
  python3 ok --local -q hailstone
  ```

  å¯¹å†°é›¹æˆ–è€…å†°é›¹åºåˆ—æ„Ÿåˆ°å¥½å¥‡ï¼Ÿçœ‹çœ‹è¿™äº›æ–‡ç« ï¼š

  - æŸ¥çœ‹[æœ¬æ–‡](https://www.nationalgeographic.org/encyclopedia/hail/)ä»¥äº†è§£æœ‰å…³å†°é›¹å¦‚ä½•å·¥ä½œçš„æ›´å¤šä¿¡æ¯ï¼

  - 2019å¹´ï¼Œåœ¨ç†è§£å†°é›¹çŒœæƒ³å¦‚ä½•é€‚ç”¨äºå¤§å¤šæ•°æ•°å­—æ–¹é¢æœ‰äº†é‡å¤§[è¿›å±•](https://www.quantamagazine.org/mathematician-terence-tao-and-the-collatz-conjecture-20191211/)ï¼

- å®ç°æ­¥éª¤

  1. è®¡æ•°ä»1å¼€å§‹ï¼Œå¹¶ä¸”ç»“å°¾è¦æ‰“å°1ï¼›
  2. whileæ¡ä»¶ä¸º n != 1ï¼Œæ“ä½œå†…å®¹ä¸ºä¸Šè¿°è¦æ±‚ä¸€è‡´ï¼›
  3. è¿”å›è®¡æ•°å€¼ï¼›

- å®ç°æ–¹æ³•

  ```python
  def hailstone(n):
      """Print the hailstone sequence starting at n and return its
      length.
  
      >>> a = hailstone(10)
      10
      5
      16
      8
      4
      2
      1
      >>> a
      7
      >>> b = hailstone(1)
      1
      >>> b
      1
      """
      "*** YOUR CODE HERE ***"
      count = 1
      while n != 1:
          print(n)
          if n % 2 == 0:
              n //= 2
          else:
              n = n * 3 + 1
          count += 1
      print(n)
      return count
  ```

- æµ‹è¯•è¯´æ˜

  æµ‹è¯•ç»“æœï¼š

  ![U4T_OQK~Y7P``WM9NHGM8DI.png](https://s2.loli.net/2022/03/19/jmcetG4uCB9rdio.png)

- å®ç°è¿‡ç¨‹

  ä»¥ä¸‹ä¸ºè¯¥ç¨‹åºçš„æ—¶é—´çº¿ï¼š

  ![_EVINBML_`U_R_XBX2F_9C1.png](https://s2.loli.net/2022/03/19/O987pIa1Wzlbx5q.png)

#### é—®é¢˜4ï¼š Product

- ä»»åŠ¡æè¿°

  é«˜é˜¶å‡½æ•°è¯¾å ‚ä¸Šä»‹ç»çš„ `summation(n, term)` å°† `term(1) + ... + term(n)` åŠ èµ·æ¥ã€‚ç¼–å†™ä¸€ä¸ªç±»ä¼¼çš„å‡½æ•° `product` ï¼Œè¿”å› `term(1) * ... * term(n)` ã€‚

  ```python
  def product(n, term):
      """Return the product of the first n terms in a sequence.
  
      n: a positive integer
      term:  a function that takes one argument to produce the term
  
      >>> product(3, identity)  # 1 * 2 * 3
      6
      >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
      120
      >>> product(3, square)    # 1^2 * 2^2 * 3^2
      36
      >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
      14400
      >>> product(3, increment) # (1+1) * (2+1) * (3+1)
      24
      >>> product(3, triple)    # 1*3 * 2*3 * 3*3
      162
      """
      "*** YOUR CODE HERE ***"
  ```

  ä½¿ç”¨ Ok æµ‹è¯•ä½ çš„ä»£ç ï¼š

  ```
  python3 ok --local -q product
  ```

- å®ç°æ­¥éª¤

  - åœ¨ hw02.py æ–‡ä»¶å¼€å¤´å·²ç»å®šä¹‰äº† squareã€identityæ–¹æ³•ï¼Œä¼ å‚çš„æ—¶å€™termç›´æ¥è¢«å…¶ä¸­ä¸€ä¸ªæ–¹æ³•ç»‘å®šï¼Œåœ¨productæ–¹æ³•ä¸­ç›´æ¥ä½¿ç”¨termå°±è¡Œï¼›

- å®ç°æ–¹æ³•

  ```python
  def product(n, term):
      """Return the product of the first n terms in a sequence.
  
      n: a positive integer
      term:  a function that takes one argument to produce the term
  
      >>> product(3, identity)  # 1 * 2 * 3
      6
      >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
      120
      >>> product(3, square)    # 1^2 * 2^2 * 3^2
      36
      >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
      14400
      >>> product(3, increment) # (1+1) * (2+1) * (3+1)
      24
      >>> product(3, triple)    # 1*3 * 2*3 * 3*3
      162
      """
      "*** YOUR CODE HERE ***"
      sum = 1
      while n > 0:
          sum *= term(n)
          n -= 1
      return sum
  ```

- æµ‹è¯•è¯´æ˜

  æµ‹è¯•ç»“æœï¼š

  ![P__D5G1T6W_P7_UPHI_6E11.png](https://s2.loli.net/2022/03/19/h8ErZXuMfNdYeWP.png)

- å®ç°è¿‡ç¨‹

  ä»¥ä¸‹ä¸ºè¯¥ç¨‹åºçš„æ—¶é—´çº¿ï¼š

  ![C3HVHDG`B_PWL__@L`13AIW.png](https://s2.loli.net/2022/03/19/nIXFBuULZbo3AHJ.png)

#### é—®é¢˜5ï¼š Accumulate

- ä»»åŠ¡æè¿°

  è®©æˆ‘ä»¬çœ‹çœ‹ `summation` å’Œ `product` æ˜¯å¦‚ä½•æˆä¸ºæ›´åŠ æ³›åŒ–çš„å‡½æ•° `accumulate` çš„å®ä¾‹çš„ï¼Œè¯·å®ç°è¯¥å‡½æ•°ã€‚

  ```python
  def accumulate(merger, start, n, term):
      """Return the result of merging the first n terms in a sequence and start.
      The terms to be merged are term(1), term(2), ..., term(n). merger is a
      two-argument commutative function.
  
      >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
      15
      >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
      26
      >>> accumulate(add, 11, 0, identity) # 11
      11
      >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
      25
      >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
      72
      >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
      >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
      19
      >>> # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2
      >>> accumulate(lambda x, y: 2 * x * y, 2, 3, square)
      576
      >>> accumulate(lambda x, y: (x + y) % 17, 19, 20, square)
      16
      """
      "*** YOUR CODE HERE ***"
  ```

  `accumulate` æœ‰å¦‚ä¸‹å‚æ•°ï¼š

  - `term` å’Œ `n`ï¼š ä¸ `summation` ï¼Œ`product` ä¸­çš„ä¸€æ ·
  - `merger`ï¼šå¸¦ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°æŒ‡å®šäº†å½“å‰é¡¹æ˜¯å¦‚ä½•å’Œä¹‹å‰ç§¯ç´¯çš„é¡¹åˆå¹¶çš„
  - `start`ï¼šç§¯ç´¯çš„èµ·å§‹å€¼

  ä¾‹å¦‚ï¼Œ`accumulate(add, 11, 3, square)` çš„ç»“æœæ˜¯

  ```
  11 + square(1) + square(2) + square(3) = 25
  ```

  > æ³¨æ„ï¼šä½ å¯ä»¥å‡å®š `merger` æ»¡è¶³äº¤æ¢å¾‹ï¼Œå³ `merger(a, b) == merger(b, a)` ã€‚ä½†ä½ ä¸èƒ½å‡å®š `merger` æ˜¯ä»ä¸€ä¸ªå›ºå®šçš„å‡½æ•°é›†ä¸­é€‰å–çš„ï¼Œå¹¶ç¡¬ç¼–ç ï¼ˆhard-codeï¼‰åˆ°ç¨‹åºä¸­ã€‚

  å®ç° `accumulate` åï¼Œå±•ç¤ºä¸€ä¸‹å®šä¹‰ `summation` å’Œ `product` æ—¶ï¼Œå¦‚ä½•é€šè¿‡è°ƒç”¨å‡½æ•° `accumulate` å®ç°çš„ã€‚

  **é‡è¦**ï¼šä½ åº”è¯¥åœ¨ `summation_using_accumulate` å’Œ `product_using_accumulate` å®ç°ä¸­ç”¨ä¸€è¡Œä»£ç ï¼ˆåº”è¯¥æ—¶ä¸€ä¸ª `return` è¯­å¥ï¼‰ï¼Œä¼šæœ‰è¯­æ³•æ£€æŸ¥çš„ã€‚

  ä½¿ç”¨ Ok æµ‹è¯•ä½ çš„ä»£ç ï¼š

  ```
  python3 ok --local -q accumulate
  python3 ok --local -q summation_using_accumulate
  python3 ok --local -q product_using_accumulate
  ```

- å®ç°æ­¥éª¤

  - accumulate
    1. ä»¥ n ä¸ºå‚æ•°çš„ term æ–¹æ³•å¾—åˆ°åˆå§‹å€¼ï¼›
    2. å…ˆè®¡ç®— n æ‰€å¯¹åº”è¡¨è¾¾å¼çš„å€¼ï¼›
    3. æœ€åè¿”å›ç”± merge ç»‘å®šçš„æ–¹æ³•è®¡ç®—å¾—åˆ°çš„æœ€ç»ˆç»“æœï¼›
  - summation_using_accumulate
    1. åŠ æ³•è¿ç®—ï¼Œmerger ç»‘å®š add æ–¹æ³•ï¼Œstart å–0ï¼›
  - product_using_accumulate 
    1. ä¹˜æ³•è¿ç®—ï¼Œmerger ç»‘å®š mul æ–¹æ³•ï¼Œstartå–1ï¼›

- å®ç°æ–¹æ³•

  - accumulate

    ```python
    def accumulate(merger, start, n, term):
        """Return the result of merging the first n terms in a sequence and start.
        The terms to be merged are term(1), term(2), ..., term(n). merger is a
        two-argument commutative function.
    
        >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
        15
        >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
        26
        >>> accumulate(add, 11, 0, identity) # 11
        11
        >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
        25
        >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
        72
        >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
        >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
        19
        >>> # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2
        >>> accumulate(lambda x, y: 2 * x * y, 2, 3, square)
        576
        >>> accumulate(lambda x, y: (x + y) % 17, 19, 20, square)
        16
        """
        result = term(n)
        while n > 1:
            n -= 1
            result = merger(result, term(n)) 
        
        return merger(result, start)
    ```

  - summation_using_accumulate

    ```python
    def summation_using_accumulate(n, term):
        """Returns the sum: term(1) + ... + term(n), using accumulate.
    
        >>> summation_using_accumulate(5, square)
        55
        >>> summation_using_accumulate(5, triple)
        45
        >>> # You aren't expected to understand the code of this test.
        >>> # Check that the bodies of the functions are just return statements.
        >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
        >>> import inspect, ast
        >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
        ['Expr', 'Return']
        """
        return accumulate(add, 0, n, term)
    ```

  - product_using_accumulate 

    ```python
    def product_using_accumulate(n, term):
        """Returns the product: term(1) * ... * term(n), using accumulate.
    
        >>> product_using_accumulate(4, square)
        576
        >>> product_using_accumulate(6, triple)
        524880
        >>> # You aren't expected to understand the code of this test.
        >>> # Check that the bodies of the functions are just return statements.
        >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
        >>> import inspect, ast
        >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
        ['Expr', 'Return']
        """
        return accumulate(mul, 1, n, term)
    ```

- æµ‹è¯•è¯´æ˜

  - accumulate æµ‹è¯•ç»“æœï¼š

    ![C`_BQOC3SBK2__X4YYJ_D@L.png](https://s2.loli.net/2022/03/19/Ex5sPuL8JVpDWTd.png)

  - summation_using_accumulate æµ‹è¯•ç»“æœï¼š

    ![X_2KAQY0K_9PD@A_6@H73G8.png](https://s2.loli.net/2022/03/19/5oVF9nwX1arPLRq.png)

  - product_using_accumulate æµ‹è¯•ç»“æœï¼š

    ![RCX2H_U3NU92KTEEME7D8OA.png](https://s2.loli.net/2022/03/19/QJ95rpeB6jA4vfM.png)

- å®ç°è¿‡ç¨‹

  ä»¥ä¸‹ä¸ºæ”¹ç¨‹åºçš„æ—¶é—´çº¿ï¼š

  ![_92_S_TIVPU_FEMN05_N`O8.png](https://s2.loli.net/2022/03/19/43NogZvUGrQcWkA.png)

#### èµé‡‘é—®é¢˜

### [1] You Again

- ä»»åŠ¡æè¿°

  > Fall 2019 MT1 Q3: [You Again](./61a-fa19-mt1.pdf) [Higher Order Functions] ï¼ˆç¬¬4é¡µç¬¬3é¢˜ï¼‰

  ```python
  Implement again, which takes a function f as an argument. The again function returns the smallest nonnegative integer n for which f(n) is equal to f(m) for some non-negative m that is less than n. Assume that f takes non-negative integers and returns the same value for at least two different non-negative arguments. 
  Constraints:
      â€¢ Lines numbered 2, 4, and 5 must begin with either while or if. 
      â€¢ Lines numbered 6 and 7 must contain either return or =.
  
  # å®ç° again æ–¹æ³•ï¼Œå®ƒå°†å‡½æ•°fä½œä¸ºå‚æ•°ï¼Œæ–¹æ³• again è¿”å›æœ€å°éè´Ÿæ•´æ•° nï¼Œä½¿å¾— f(n) ç­‰äº f(m)ä¸­ä¸€äº›å°äº n çš„éè´Ÿæ­£æ•´æ•° mã€‚å‡è®¾ fä¸ºéè´Ÿæ•´æ•°ï¼Œå¹¶ä¸”è¿”å› ç›¸# åŒçš„å€¼
  
  def parabola(x): 
      """A parabola function (for testing the again function)."""
  	return (x-3) * (x-6)
  def vee(x): 
      """A V-shaped function (for testing the again function).""" 
      return abs(x-2)
  def again(f):
      """Return the smallest non-negative integer n such that f(n) == f(m) for some m < n.
  	>>> again(parabola) # parabola(4) == parabola(5)
      5
  	>>> again(vee)
      3
  	"""
  1 n = 1
  2 _________________________________________________________________________:
  3 m = 0 
  4 	_______________________________________________________________________:
  5 		___________________________________________________________________:
  6 			______________________________________________________________
  7 		___________________________________________________________________
  8 n = n + 1 
  ```

  

- å®ç°æ­¥éª¤

- å®ç°æ–¹æ³•

- æµ‹è¯•è¯´æ˜

- å®ç°è¿‡ç¨‹

### [2] Domain on the Range

- ä»»åŠ¡æè¿°
- å®ç°æ­¥éª¤
- å®ç°æ–¹æ³•
- æµ‹è¯•è¯´æ˜
- å®ç°è¿‡ç¨‹

### [3] tik

- ä»»åŠ¡æè¿°
- å®ç°æ­¥éª¤
- å®ç°æ–¹æ³•
- æµ‹è¯•è¯´æ˜
- å®ç°è¿‡ç¨‹

- ä»»åŠ¡æè¿°

  è¯¾åä½œä¸šä¸­ä¹Ÿä¼šåŒ…æ‹¬ä¹‹å‰çš„è€ƒè¯•é—®é¢˜ï¼Œä½ å¯ä»¥çœ‹çœ‹ã€‚è¿™äº›é—®é¢˜ä¸åšè¦æ±‚ï¼Œå°½ç®¡å°è¯•æŒ‘æˆ˜ä¸€ä¸‹ã€‚

  1. Fall 2019 MT1 Q3: [You Again](./61a-fa19-mt1.pdf) [Higher Order Functions] ï¼ˆç¬¬4é¡µç¬¬3é¢˜ï¼‰
  2. Spring 2021 MT1 Q4: [Domain on the Range](./61a-sp21-mt1.pdf) [Higher Order Functions] ï¼ˆç¬¬14é¡µç¬¬4é¢˜ï¼‰

  3. Fall 2021 MT1 Q1b: [tik](./61a-fa21-mt1.pdf) [Functions and Expressions] ï¼ˆç¬¬4é¡µç¬¬3ï¼ˆbï¼‰é¢˜ï¼‰

- å®ç°æ­¥éª¤
- å®ç°æ–¹æ³•
- æµ‹è¯•è¯´æ˜
- å®ç°è¿‡ç¨‹

## äº” å®éªŒå¿ƒå¾—

> æ€»ç»“è‡ªå·±çš„å®ç°è¿‡ç¨‹ä¸­äº§ç”Ÿçš„æ„Ÿå—å’Œå¿ƒå¾—ï¼Œçªå‡ºä¸€åˆ†è€•è€˜ä¸€åˆ†æ”¶è·ã€‚



