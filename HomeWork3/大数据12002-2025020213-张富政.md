## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      计算机与人工智能学院《人工智能程序设计》实验报告📝

| 专业                 | 学号         | 姓名         |
| :------------------- | ------------ | ------------ |
| 数据科学与大数据技术 | 2025020213   | 张富政       |
| **课程名称**         | **实验名称** | **完成日期** |
| 专业综合训练I        | 实训一       | 2022.03.19   |



[TOC]

## 一 实验目标

> 描述本次实验所需实现的目标，请根据实验说明文档填写。

例如：

- 掌握Vs Code、github的使用；
- 掌握使用Makefile进行工程编译的方法；
- 掌握编程文档的撰写方法；
- 复习文件、单链表的编程；
- 巩固排序算法。	

## 二 实验要求

> 实验完成的具体要求说明。

- 个人独立完成，积极动手编程；
- 鼓励与同学交流，但不能抄袭源码；
- 能完成实验说明文档的各个步骤并撰写此实验报告；
- 能演示实验过程并阐述功能的主要代码模块。
- 实验报告请突出自己的**想法**、**做法**、**心得体会**；

## 三 实验环境

> 列举实验完成过程中使用到的主要工具以及主要的**参考资料**。

例如：

- Vs Code、Github、Typora；
- 书：
- 网站：



## 四 实验内容

> 报告的**主体部分**。详细说明每部分任务的任务描述、实现步骤、实现方法、测试说明、实现痕迹，实现方法请==突出重点==，不必泛泛而谈。
>
> 任务描述：简要说明此任务需要达到的目的；
>
> 实现步骤：实现此任务大致分为哪几个阶段步骤；
>
> 实现方法：实现这些步骤时用到了哪些主要的方法（数据结构、算法、编程技巧等）；
>
> 测试说明：设计测试样例说明任务完成情况；
>
> 实现过程：git 时间线展示和说明。

###  Person问题

#### 问题1：Count Until Larger

- 任务描述

  实现函数 `count_until_larger` , 该函数接受一个正整数 `num` ，统计最右边数位（digit）和离它最近并比它大的数位的距离。是这样做的，函数从右往左计数，一旦遇到比最右边数位大的数位，就返回这个计数，如果不存在这样的数位，就返回 -1

  例如， 8117 的最右边数位是 `7` 并返回计数 `3` 。9118117 也返回计数 `3`，两个都是在 `8` 停止计数。

  数字 `0` 应该按无数位对待并返回 `-1` 。

  参阅下面的 doctest，了解 `count_until_larger` 的具体行为。

  > count_until_larger.py源代码文件在 parsons_probs 文件夹中，在终端通过 `cd` 命令进入该文件夹，并输入命令进行验证：
  >
  > ```
  > python3 -m doctest count_until_larger.py
  > ```

  ```python
  def count_until_larger(num):
      """
      Complete the function count_until_larger that takes in a positive integer num.
      count_until_larger examines the rightmost digit and counts digits from right to
      left until it encounters a digit larger than the rightmost digit, then returns that count.
  
      >>> count_until_larger(117) # .Case 1
      -1
      >>> count_until_larger(8117) # .Case 2
      3
      >>> count_until_larger(9118117) # .Case 3
      3
      >>> count_until_larger(8777)  # .Case 4
      3
      >>> count_until_larger(22) # .Case 5
      -1
      >>> count_until_larger(0) # .Case 6
      -1
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  1. 以num最后一位为基准，用num对10取模结果与最后一位比较，只要有较大数就立即返回；
  2. 直到num为0都无返回值，则返回-1；

- 实现方法

  ```python
  def count_until_larger(num):
      """
      Complete the function count_until_larger that takes in a positive integer num.
      count_until_larger examines the rightmost digit and counts digits from right to
      left until it encounters a digit larger than the rightmost digit, then returns that count.
  
      >>> count_until_larger(117) # .Case 1
      -1
      >>> count_until_larger(8117) # .Case 2
      3
      >>> count_until_larger(9118117) # .Case 3
      3
      >>> count_until_larger(8777)  # .Case 4
      3
      >>> count_until_larger(22) # .Case 5
      -1
      >>> count_until_larger(0) # .Case 6
      -1
      """
      "*** YOUR CODE HERE ***"
      k = num % 10
      num //= 10
      count = 0
      while num:
          count += 1
          if num % 10 > k:
              return count
          num //= 10
      return -1
  ```

- 测试说明

  测试结果：

  ![DY_HZ3044IELQ5@VX__MH2E.png](https://s2.loli.net/2022/03/19/TKQMFH8IORPYpfe.png)

- 实现过程

  以下为该程序的时间线：

  ![XR_T_ENRFI_`GZ_EW7_B_SU.png](https://s2.loli.net/2022/03/19/Ql3uz7b9BUOqMjn.png)

#### 问题2：Filter Sequence

- 任务描述

  编写函数 `filter_sequence` ，接受两个整数 `start` 和 `stop` ，和一个函数 `cond`，`cond` 接受一个参数并输出一个布尔值。

   当 `cond` 返回 `True` 时，`filter_sequence` 返回从 `start` 到 `stop` （包括）的所有数位（digit）之和。

  > filter_sequence.py源代码文件在 parsons_probs 文件夹中，在终端通过 `cd` 命令进入该文件夹，并输入命令进行验证：
  >
  > ```
  > python3 -m doctest filter_sequence.py
  > ```

  ```python
  def filter_sequence(cond, start, stop):
      """
      Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy
      the one-argument function cond.
  
      >>> filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1
      30
      >>> filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2
      25
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  1. 用for循环range返回的数列；
  2. 对数列中的数用cond函数判断 True or False，True：sum+，False：不做处理；
  3. 返回结果；

- 实现方法

  ```python
  def filter_sequence(cond, start, stop):
      """
      Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy
      the one-argument function cond.
  
      >>> filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1
      30
      >>> filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2
      25
      """
      "*** YOUR CODE HERE ***"
      sum = 0
      for i in range(start, stop + 1):
          if cond(i):
              sum += i
      return sum
  ```

- 测试说明

  测试结果：

  ![YBUEK_6E_~GUH73_8SJF`_Y.png](https://s2.loli.net/2022/03/19/xekntCUV3GhTlDu.png)

- 实现过程

  以下为该程序的时间线：

  ![LU_`NK`XGN_`JXZR2_0_MDR.png](https://s2.loli.net/2022/03/19/9hAk8wDHlYUdoZn.png)

  

### 编程问题

#### 问题3：Hailstone

- 任务描述

  Douglas Hofstadter 的普利策奖获奖著作《*Gödel， Escher， Bach*》提出了以下数学难题。

  1. 选择一个正整数 `n` 作为开始。
  2. 如果 `n` 为偶数，则将其除以 2。
  3. 如果 `n` 为奇数，则将其乘以 3 并加 1。
  4. 继续此过程，直到 `n` 为 1。

  这个数字 `n` 会上下移动，但最终以1结束（至少对于所有尝试过的数字成立 - 没有人证明序列会终止）。类比于冰雹（hailstone）在大气层中上下移动，最终降落在地球上。

   `n` 的值序列通常被称为冰雹序列。编写一个函数，接受一个正式的参数名 `n`，打印出从 `n` 开始的冰雹序列，并返回序列中的步数：

  

  编写函数 `falling`，接受两个参数 `n` 和 `k` ， 返回 从 `n` 开始的倒数 `k` 个连续数字之积。当 `k` 为 `0` 时，函数返回`1`

  ```python
  def hailstone(n):
      """Print the hailstone sequence starting at n and return its
      length.
  
      >>> a = hailstone(10)
      10
      5
      16
      8
      4
      2
      1
      >>> a
      7
      >>> b = hailstone(1)
      1
      >>> b
      1
      """
      "*** YOUR CODE HERE ***"
  ```

  冰雹序列可以非常长！试试 27。你能找到的最长序列是？

  使用 Ok 测试你的代码：

  ```
  python3 ok --local -q hailstone
  ```

  对冰雹或者冰雹序列感到好奇？看看这些文章：

  - 查看[本文](https://www.nationalgeographic.org/encyclopedia/hail/)以了解有关冰雹如何工作的更多信息！

  - 2019年，在理解冰雹猜想如何适用于大多数数字方面有了重大[进展](https://www.quantamagazine.org/mathematician-terence-tao-and-the-collatz-conjecture-20191211/)！

- 实现步骤

  1. 计数从1开始，并且结尾要打印1；
  2. while条件为 n != 1，操作内容为上述要求一致；
  3. 返回计数值；

- 实现方法

  ```python
  def hailstone(n):
      """Print the hailstone sequence starting at n and return its
      length.
  
      >>> a = hailstone(10)
      10
      5
      16
      8
      4
      2
      1
      >>> a
      7
      >>> b = hailstone(1)
      1
      >>> b
      1
      """
      "*** YOUR CODE HERE ***"
      count = 1
      while n != 1:
          print(n)
          if n % 2 == 0:
              n //= 2
          else:
              n = n * 3 + 1
          count += 1
      print(n)
      return count
  ```

- 测试说明

  测试结果：

  ![U4T_OQK~Y7P``WM9NHGM8DI.png](https://s2.loli.net/2022/03/19/jmcetG4uCB9rdio.png)

- 实现过程

  以下为该程序的时间线：

  ![_EVINBML_`U_R_XBX2F_9C1.png](https://s2.loli.net/2022/03/19/O987pIa1Wzlbx5q.png)

#### 问题4： Product

- 任务描述

  高阶函数课堂上介绍的 `summation(n, term)` 将 `term(1) + ... + term(n)` 加起来。编写一个类似的函数 `product` ，返回 `term(1) * ... * term(n)` 。

  ```python
  def product(n, term):
      """Return the product of the first n terms in a sequence.
  
      n: a positive integer
      term:  a function that takes one argument to produce the term
  
      >>> product(3, identity)  # 1 * 2 * 3
      6
      >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
      120
      >>> product(3, square)    # 1^2 * 2^2 * 3^2
      36
      >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
      14400
      >>> product(3, increment) # (1+1) * (2+1) * (3+1)
      24
      >>> product(3, triple)    # 1*3 * 2*3 * 3*3
      162
      """
      "*** YOUR CODE HERE ***"
  ```

  使用 Ok 测试你的代码：

  ```
  python3 ok --local -q product
  ```

- 实现步骤

  - 在 hw02.py 文件开头已经定义了 square、identity方法，传参的时候term直接被其中一个方法绑定，在product方法中直接使用term就行；

- 实现方法

  ```python
  def product(n, term):
      """Return the product of the first n terms in a sequence.
  
      n: a positive integer
      term:  a function that takes one argument to produce the term
  
      >>> product(3, identity)  # 1 * 2 * 3
      6
      >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
      120
      >>> product(3, square)    # 1^2 * 2^2 * 3^2
      36
      >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
      14400
      >>> product(3, increment) # (1+1) * (2+1) * (3+1)
      24
      >>> product(3, triple)    # 1*3 * 2*3 * 3*3
      162
      """
      "*** YOUR CODE HERE ***"
      sum = 1
      while n > 0:
          sum *= term(n)
          n -= 1
      return sum
  ```

- 测试说明

  测试结果：

  ![P__D5G1T6W_P7_UPHI_6E11.png](https://s2.loli.net/2022/03/19/h8ErZXuMfNdYeWP.png)

- 实现过程

  以下为该程序的时间线：

  ![C3HVHDG`B_PWL__@L`13AIW.png](https://s2.loli.net/2022/03/19/nIXFBuULZbo3AHJ.png)

#### 问题5： Accumulate

- 任务描述

  让我们看看 `summation` 和 `product` 是如何成为更加泛化的函数 `accumulate` 的实例的，请实现该函数。

  ```python
  def accumulate(merger, start, n, term):
      """Return the result of merging the first n terms in a sequence and start.
      The terms to be merged are term(1), term(2), ..., term(n). merger is a
      two-argument commutative function.
  
      >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
      15
      >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
      26
      >>> accumulate(add, 11, 0, identity) # 11
      11
      >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
      25
      >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
      72
      >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
      >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
      19
      >>> # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2
      >>> accumulate(lambda x, y: 2 * x * y, 2, 3, square)
      576
      >>> accumulate(lambda x, y: (x + y) % 17, 19, 20, square)
      16
      """
      "*** YOUR CODE HERE ***"
  ```

  `accumulate` 有如下参数：

  - `term` 和 `n`： 与 `summation` ，`product` 中的一样
  - `merger`：带两个参数的函数指定了当前项是如何和之前积累的项合并的
  - `start`：积累的起始值

  例如，`accumulate(add, 11, 3, square)` 的结果是

  ```
  11 + square(1) + square(2) + square(3) = 25
  ```

  > 注意：你可以假定 `merger` 满足交换律，即 `merger(a, b) == merger(b, a)` 。但你不能假定 `merger` 是从一个固定的函数集中选取的，并硬编码（hard-code）到程序中。

  实现 `accumulate` 后，展示一下定义 `summation` 和 `product` 时，如何通过调用函数 `accumulate` 实现的。

  **重要**：你应该在 `summation_using_accumulate` 和 `product_using_accumulate` 实现中用一行代码（应该时一个 `return` 语句），会有语法检查的。

  使用 Ok 测试你的代码：

  ```
  python3 ok --local -q accumulate
  python3 ok --local -q summation_using_accumulate
  python3 ok --local -q product_using_accumulate
  ```

- 实现步骤

  - accumulate
    1. 以 n 为参数的 term 方法得到初始值；
    2. 先计算 n 所对应表达式的值；
    3. 最后返回由 merge 绑定的方法计算得到的最终结果；
  - summation_using_accumulate
    1. 加法运算，merger 绑定 add 方法，start 取0；
  - product_using_accumulate 
    1. 乘法运算，merger 绑定 mul 方法，start取1；

- 实现方法

  - accumulate

    ```python
    def accumulate(merger, start, n, term):
        """Return the result of merging the first n terms in a sequence and start.
        The terms to be merged are term(1), term(2), ..., term(n). merger is a
        two-argument commutative function.
    
        >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
        15
        >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
        26
        >>> accumulate(add, 11, 0, identity) # 11
        11
        >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
        25
        >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
        72
        >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
        >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
        19
        >>> # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2
        >>> accumulate(lambda x, y: 2 * x * y, 2, 3, square)
        576
        >>> accumulate(lambda x, y: (x + y) % 17, 19, 20, square)
        16
        """
        result = term(n)
        while n > 1:
            n -= 1
            result = merger(result, term(n)) 
        
        return merger(result, start)
    ```

  - summation_using_accumulate

    ```python
    def summation_using_accumulate(n, term):
        """Returns the sum: term(1) + ... + term(n), using accumulate.
    
        >>> summation_using_accumulate(5, square)
        55
        >>> summation_using_accumulate(5, triple)
        45
        >>> # You aren't expected to understand the code of this test.
        >>> # Check that the bodies of the functions are just return statements.
        >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
        >>> import inspect, ast
        >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
        ['Expr', 'Return']
        """
        return accumulate(add, 0, n, term)
    ```

  - product_using_accumulate 

    ```python
    def product_using_accumulate(n, term):
        """Returns the product: term(1) * ... * term(n), using accumulate.
    
        >>> product_using_accumulate(4, square)
        576
        >>> product_using_accumulate(6, triple)
        524880
        >>> # You aren't expected to understand the code of this test.
        >>> # Check that the bodies of the functions are just return statements.
        >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
        >>> import inspect, ast
        >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
        ['Expr', 'Return']
        """
        return accumulate(mul, 1, n, term)
    ```

- 测试说明

  - accumulate 测试结果：

    ![C`_BQOC3SBK2__X4YYJ_D@L.png](https://s2.loli.net/2022/03/19/Ex5sPuL8JVpDWTd.png)

  - summation_using_accumulate 测试结果：

    ![X_2KAQY0K_9PD@A_6@H73G8.png](https://s2.loli.net/2022/03/19/5oVF9nwX1arPLRq.png)

  - product_using_accumulate 测试结果：

    ![RCX2H_U3NU92KTEEME7D8OA.png](https://s2.loli.net/2022/03/19/QJ95rpeB6jA4vfM.png)

- 实现过程

  以下为改程序的时间线：

  ![_92_S_TIVPU_FEMN05_N`O8.png](https://s2.loli.net/2022/03/19/43NogZvUGrQcWkA.png)

#### 赏金问题

### [1] You Again

- 任务描述

  > Fall 2019 MT1 Q3: [You Again](./61a-fa19-mt1.pdf) [Higher Order Functions] （第4页第3题）

  ```python
  Implement again, which takes a function f as an argument. The again function returns the smallest nonnegative integer n for which f(n) is equal to f(m) for some non-negative m that is less than n. Assume that f takes non-negative integers and returns the same value for at least two different non-negative arguments. 
  Constraints:
      • Lines numbered 2, 4, and 5 must begin with either while or if. 
      • Lines numbered 6 and 7 must contain either return or =.
  
  # 实现 again 方法，它将函数f作为参数，方法 again 返回最小非负整数 n，使得 f(n) 等于 f(m)中一些小于 n 的非负正整数 m。假设 f为非负整数，并且返回 相# 同的值
  
  def parabola(x): 
      """A parabola function (for testing the again function)."""
  	return (x-3) * (x-6)
  def vee(x): 
      """A V-shaped function (for testing the again function).""" 
      return abs(x-2)
  def again(f):
      """Return the smallest non-negative integer n such that f(n) == f(m) for some m < n.
  	>>> again(parabola) # parabola(4) == parabola(5)
      5
  	>>> again(vee)
      3
  	"""
  1 n = 1
  2 _________________________________________________________________________:
  3 m = 0 
  4 	_______________________________________________________________________:
  5 		___________________________________________________________________:
  6 			______________________________________________________________
  7 		___________________________________________________________________
  8 n = n + 1 
  ```

  

- 实现步骤

- 实现方法

- 测试说明

- 实现过程

### [2] Domain on the Range

- 任务描述
- 实现步骤
- 实现方法
- 测试说明
- 实现过程

### [3] tik

- 任务描述
- 实现步骤
- 实现方法
- 测试说明
- 实现过程

- 任务描述

  课后作业中也会包括之前的考试问题，你可以看看。这些问题不做要求，尽管尝试挑战一下。

  1. Fall 2019 MT1 Q3: [You Again](./61a-fa19-mt1.pdf) [Higher Order Functions] （第4页第3题）
  2. Spring 2021 MT1 Q4: [Domain on the Range](./61a-sp21-mt1.pdf) [Higher Order Functions] （第14页第4题）

  3. Fall 2021 MT1 Q1b: [tik](./61a-fa21-mt1.pdf) [Functions and Expressions] （第4页第3（b）题）

- 实现步骤
- 实现方法
- 测试说明
- 实现过程

## 五 实验心得

> 总结自己的实现过程中产生的感受和心得，突出一分耕耘一分收获。



